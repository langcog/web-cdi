# -*- coding: utf-8 -*-
# Generated by Django 1.11.5 on 2018-05-17 22:45
from __future__ import unicode_literals

from django.db import migrations, models
import django.db.models.deletion
from django.conf import settings
import csv, json, os, re, string
from django.core.exceptions import FieldError

def unicode_csv_reader(utf8_data, dialect=csv.excel, **kwargs):
    csv_reader = csv.reader(utf8_data, dialect=dialect, **kwargs)
    for row in csv_reader:
        yield [unicode(cell, 'utf-8') for cell in row]

def populate_items(apps, schema_editor):
    PROJECT_ROOT = settings.BASE_DIR
    input_instruments = json.load(open(os.path.realpath(PROJECT_ROOT + '/static/json/instruments.json')))
    instrument = apps.get_model('researcher_UI', 'instrument')
    var_safe = lambda s: ''.join([c for c in '_'.join(s.split()) if c in string.letters + string.digits + '_'])

    try:
        Choices = apps.get_model('cdi_forms', 'Choices')
    except LookupError:
        Choices = None

    for curr_instrument in input_instruments:

        instrument_language, instrument_form = curr_instrument['language'], curr_instrument['form']
        instrument_name = var_safe(instrument_language) + '_' + var_safe(instrument_form)
        print "    Populating items for", instrument_language, instrument_form

        if instrument.objects.filter(form=instrument_form, language=instrument_language).exists():
            instrument_obj = instrument.objects.get(form=instrument_form, language=instrument_language)
        elif instrument.objects.filter(name=instrument_name).exists():
            instrument_obj = instrument.objects.get(name=instrument_name)
        else:
            continue

        instrument_forms = apps.get_model(app_label='cdi_forms', model_name='Instrument_Forms')

        ftype = curr_instrument['csv_file'].split('.')[-1]

        if ftype == 'csv':

            contents = list(unicode_csv_reader(open(os.path.realpath(PROJECT_ROOT + '/' + curr_instrument['csv_file']))))
            col_names = contents[0]
            nrows = len(contents)
            get_row = lambda row: contents[row]
        else:
            raise IOError("Instrument file must be a CSV.")

        for row in xrange(1, nrows):
            row_values = get_row(row)
            if len(row_values) > 1:
                itemID = row_values[col_names.index('itemID')]
                item = row_values[col_names.index('item')]
                item_type = row_values[col_names.index('item_type')]
                item_category = row_values[col_names.index('category')]
                item_choices = row_values[col_names.index('choices')]
                choices_key = None
                #if item_type not in ['combination_examples']:
                if not 'examples' in item_type:
                    try:
                        if Choices:
                            choices_key = Choices.objects.get(choice_set_en = item_choices)
                        else:
                            choices_key = item_choices
                    except:
                        raise IOError("Can't find choice set %s in model for %s (%s)" % (item_category, itemID, item_choices, ))

                definition = row_values[col_names.index('definition')]
                gloss = row_values[col_names.index('gloss')]
                if 'complexity_category' in col_names:
                    complexity_category = row_values[col_names.index('complexity_category')]
                else:
                    complexity_category = None

                if 'uni_lemma' in col_names:
                    uni_lemma = row_values[col_names.index('uni_lemma')]
                else:
                    uni_lemma = None

                data_dict = {'item': item,
                             'item_type': item_type,
                             'category': item_category,
                             'choices': choices_key,
                             'definition': definition,
                             'gloss': gloss,
                             'complexity_category': complexity_category,
                             'uni_lemma': uni_lemma}

                instrument_forms.objects.update_or_create(instrument = instrument_obj, itemID = itemID, defaults=data_dict,)

class Migration(migrations.Migration):

    dependencies = [
        ('researcher_UI', '0026_build_researcher_model'),
        ('cdi_forms', '0042_rename_caregiver_choices'),
    ]

    operations = [
        migrations.CreateModel(
            name='Instrument_Forms',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('itemID', models.CharField(db_index=True, max_length=101)),
                ('item', models.CharField(max_length=101)),
                ('item_type', models.CharField(max_length=101)),
                ('category', models.CharField(max_length=101)),
                ('definition', models.CharField(blank=True, max_length=1001, null=True)),
                ('gloss', models.CharField(blank=True, max_length=1001, null=True)),
                ('complexity_category', models.CharField(blank=True, max_length=101, null=True)),
                ('uni_lemma', models.CharField(blank=True, max_length=101, null=True)),
                ('choices', models.ForeignKey(null=True, on_delete=django.db.models.deletion.PROTECT, to='cdi_forms.Choices')),
                ('instrument', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='researcher_UI.instrument')),
            ],
        ),
        migrations.AlterUniqueTogether(
            name='instrument_forms',
            unique_together=set([('instrument', 'itemID')]),
        ),
        migrations.RunPython(populate_items),

    ]
